---
phase: 02-terminal-textedit-persistence
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/textedit.rs
autonomous: true

must_haves:
  truths:
    - "TextEdit document content persists across page refresh"
    - "TextEdit toolbar settings (font size, font family, alignment) persist across page refresh"
    - "User can type formatted text, refresh, and see their content preserved"
    - "Bold/italic/underline formatting within content is preserved"
    - "TextEdit gracefully handles missing or corrupted storage"
  artifacts:
    - path: "src/textedit.rs"
      provides: "TextEditState struct, save/load functions, content persistence"
      contains: "TextEditState"
      min_lines: 280
  key_links:
    - from: "src/textedit.rs"
      to: "localStorage"
      via: "save_to_storage on input"
      pattern: "storage\\.set_item.*virtualmac_textedit"
    - from: "src/textedit.rs"
      to: "localStorage"
      via: "load_from_storage on mount"
      pattern: "storage\\.get_item.*virtualmac_textedit"
---

<objective>
Add localStorage persistence to TextEdit for document content and toolbar settings.

Purpose: Extend the Phase 1 persistence pattern to TextEdit. Users can draft text, close the browser, return later, and have their document preserved with formatting intact.

Output: TextEdit with persisted HTML content and toolbar settings (font size, font family, alignment) that survive page refresh.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-terminal-textedit-persistence/02-RESEARCH.md
@src/calculator.rs (lines 1-85 - reference persistence pattern)
@src/notes.rs (lines 78-120 - reference HTML content persistence)
@src/textedit.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add persistence infrastructure to TextEdit</name>
  <files>src/textedit.rs</files>
  <action>
Add TextEditState struct and persistence following the Calculator pattern:

1. Add imports at top of file (after existing imports):
   ```rust
   use serde::{Deserialize, Serialize};
   ```

2. Create constants and serializable state struct (before the component):
   ```rust
   #[allow(dead_code)]
   const STORAGE_KEY: &str = "virtualmac_textedit";
   #[allow(dead_code)]
   const CURRENT_SCHEMA_VERSION: u32 = 1;

   #[derive(Clone, Debug, Serialize, Deserialize)]
   struct TextEditState {
       schema_version: u32,
       content: String,
       font_size: u32,
       font_family: String,
       alignment: String,
   }

   impl Default for TextEditState {
       fn default() -> Self {
           Self {
               schema_version: CURRENT_SCHEMA_VERSION,
               content: String::new(),
               font_size: 16,
               font_family: "Helvetica Neue".to_string(),
               alignment: "left".to_string(),
           }
       }
   }
   ```

3. Add save_to_storage function (platform-gated):
   ```rust
   fn save_to_storage(state: &TextEditState) {
       #[cfg(target_arch = "wasm32")]
       {
           if let Some(window) = web_sys::window() {
               if let Ok(Some(storage)) = window.local_storage() {
                   if let Ok(json) = serde_json::to_string(state) {
                       let _ = storage.set_item(STORAGE_KEY, &json);
                   }
               }
           }
       }
       #[cfg(not(target_arch = "wasm32"))]
       {
           let _ = state;
       }
   }
   ```

4. Add load_from_storage function (platform-gated, graceful degradation):
   ```rust
   fn load_from_storage() -> TextEditState {
       #[cfg(target_arch = "wasm32")]
       {
           if let Some(window) = web_sys::window() {
               if let Ok(Some(storage)) = window.local_storage() {
                   if let Ok(Some(json)) = storage.get_item(STORAGE_KEY) {
                       if let Ok(state) = serde_json::from_str::<TextEditState>(&json) {
                           return state;
                       }
                   }
               }
           }
       }
       TextEditState::default()
   }
   ```

5. In TextEdit component, initialize textedit_state from storage:
   ```rust
   let (textedit_state, set_textedit_state) = signal(load_from_storage());
   ```

6. Initialize existing signals from textedit_state (modify existing lines):
   ```rust
   let initial_state = textedit_state.get_untracked();
   let (font_size, set_font_size) = signal(initial_state.font_size);
   let (font_family, set_font_family) = signal(initial_state.font_family);
   let (alignment, set_alignment) = signal(initial_state.alignment);
   ```

7. Add Effect to restore content on mount (after doc_ref is created):
   ```rust
   // Restore content on mount - run once
   Effect::new({
       let doc_ref = doc_ref.clone();
       let textedit_state = textedit_state;
       move |prev_ran: Option<bool>| {
           if prev_ran.is_none() {
               if let Some(el) = doc_ref.get() {
                   let state = textedit_state.get_untracked();
                   if !state.content.is_empty() {
                       el.set_inner_html(&state.content);
                   }
               }
           }
           Some(true)
       }
   });
   ```

8. Update update_counts handler to also save content:
   ```rust
   let update_counts = move |_| {
       if let Some(el) = doc_ref.get() {
           let text = el.inner_text();
           let chars = text.chars().count();
           let words = text.split_whitespace().count();
           set_char_count.set(chars);
           set_word_count.set(words);

           // Save content
           let content = el.inner_html();
           set_textedit_state.update(|state| {
               state.content = content;
           });
       }
   };
   ```

9. Update on_font_change to persist:
   ```rust
   let on_font_change = move |e: web_sys::Event| {
       let target = e.target().unwrap();
       let select = target.dyn_into::<web_sys::HtmlSelectElement>().unwrap();
       let value = select.value();
       set_font_family.set(value.clone());
       execCommand("fontName", false, &value);
       // Persist
       set_textedit_state.update(|state| {
           state.font_family = value;
       });
   };
   ```

10. Update on_size_change to persist:
    ```rust
    let on_size_change = move |e: web_sys::Event| {
        let target = e.target().unwrap();
        let select = target.dyn_into::<web_sys::HtmlSelectElement>().unwrap();
        let value = select.value();
        if let Ok(size) = value.parse::<u32>() {
            set_font_size.set(size);
            // Persist
            set_textedit_state.update(|state| {
                state.font_size = size;
            });
        }
    };
    ```

11. Update set_align to persist:
    ```rust
    let set_align = move |align: &'static str| {
        move |e: MouseEvent| {
            e.prevent_default();
            let cmd = match align {
                "left" => "justifyLeft",
                "center" => "justifyCenter",
                "right" => "justifyRight",
                "justify" => "justifyFull",
                _ => "justifyLeft",
            };
            execCommand(cmd, false, "");
            set_alignment.set(align.to_string());
            // Persist
            set_textedit_state.update(|state| {
                state.alignment = align.to_string();
            });
        }
    };
    ```

12. Add Effect for auto-save on textedit_state changes:
    ```rust
    Effect::new(move |_| {
        let current_state = textedit_state.get();
        save_to_storage(&current_state);
    });
    ```

13. Update the contenteditable div to NOT show placeholder if content exists:
    - Change from static "Start typing here..." to conditional
    - The content restoration Effect will handle setting innerHTML

IMPORTANT:
- Use innerHTML (not innerText) to preserve formatting (bold, italic, etc.)
- Save content on input event (each keystroke is fine for text editor)
- Do NOT persist transient state like is_bold, is_underline (derived from selection)
  </action>
  <verify>
Run `cargo build --all-targets --all-features` - should compile without errors.
Run `cargo clippy --all-targets --all-features -- -D warnings` - should pass.
Run `cargo fmt --all` - should format code.
  </verify>
  <done>
TextEditState struct exists with schema_version, content, font_size, font_family, alignment fields. save_to_storage and load_from_storage functions exist. Content saved on input. Settings saved on change. Content restored on mount. textedit_state signal initialized from storage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify TextEdit persistence works end-to-end</name>
  <files>src/textedit.rs</files>
  <action>
Manual verification steps (no code changes needed, just testing):

1. Run `trunk serve` and open the app in browser
2. Open TextEdit app
3. Type some text: "Hello World"
4. Select "Hello" and make it bold (B button)
5. Change font size to 24
6. Change alignment to center
7. Refresh the page (F5 or Cmd+R)
8. Open TextEdit again
9. Verify:
   - Content is preserved ("Hello World")
   - "Hello" is still bold
   - Font size dropdown shows 24
   - Alignment buttons show center as active
   - Text is actually centered

If any issues found, fix them in the textedit.rs file.

Common issues to check:
- Content not loading: Check Effect runs on mount and sets innerHTML
- Formatting lost: Check using innerHTML not innerText
- Settings not loading: Check initial_state is used for signal initialization
- Placeholder showing with content: Check Effect replaces initial content

After verification, run final checks:
- `cargo fmt --all`
- `cargo clippy --all-targets --all-features -- -D warnings`
- `cargo build --all-targets --all-features`
- `cargo test --all-features`
  </action>
  <verify>
1. Page refresh preserves document content
2. Page refresh preserves formatting (bold, italic, etc.)
3. Page refresh preserves font size selection
4. Page refresh preserves font family selection
5. Page refresh preserves alignment
6. No console errors related to localStorage
7. All cargo checks pass
  </verify>
  <done>
TextEdit document content survives page refresh. Formatting (bold/italic/underline) survives refresh. Toolbar settings (font size, font family, alignment) survive refresh. All Rust pre-commit checks pass.
  </done>
</task>

</tasks>

<verification>
Phase-level verification for TextEdit:

1. **Content persists:**
   - Open TextEdit, type "Test document"
   - Refresh page
   - Open TextEdit - content is there

2. **Formatting persists:**
   - Open TextEdit, type "Bold Italic Normal"
   - Select "Bold" and make bold
   - Select "Italic" and make italic
   - Refresh page
   - Open TextEdit - formatting preserved

3. **Font size persists:**
   - Change font size to 24
   - Refresh page
   - Font size dropdown shows 24, text displays at 24px

4. **Font family persists:**
   - Change font to Monaco
   - Refresh page
   - Font dropdown shows Monaco, text displays in Monaco

5. **Alignment persists:**
   - Click center align button
   - Refresh page
   - Center button is active, text is centered

6. **Graceful degradation:**
   - Clear localStorage: `localStorage.removeItem('virtualmac_textedit')`
   - Refresh page - TextEdit works with defaults (empty doc, 16px, Helvetica, left)
   - No console errors

7. **Code quality:**
   - `cargo fmt --all`
   - `cargo clippy --all-targets --all-features -- -D warnings`
   - `cargo build --all-targets --all-features`
   - `cargo test --all-features`
</verification>

<success_criteria>
- TextEdit document content (HTML) persists across page refresh
- Bold/italic/underline formatting within content persists
- Font size selection persists
- Font family selection persists
- Alignment selection persists
- State stored in `virtualmac_textedit` localStorage key
- Graceful fallback to defaults if storage unavailable/corrupted
- All Rust pre-commit checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-terminal-textedit-persistence/02-02-SUMMARY.md`
</output>
