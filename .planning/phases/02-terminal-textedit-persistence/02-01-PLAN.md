---
phase: 02-terminal-textedit-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/terminal.rs
autonomous: true

must_haves:
  truths:
    - "Terminal command history persists across page refresh"
    - "Terminal current working directory persists across page refresh"
    - "User can press up/down arrows to recall previous commands after refresh"
    - "Command history is limited to 1000 entries to prevent storage exhaustion"
    - "Terminal output history does NOT persist (matches real Terminal behavior)"
    - "Terminal gracefully handles missing or corrupted storage"
  artifacts:
    - path: "src/terminal.rs"
      provides: "TerminalState struct, save/load functions, persistence on command execution"
      contains: "TerminalState"
      min_lines: 500
  key_links:
    - from: "src/terminal.rs"
      to: "localStorage"
      via: "save_to_storage on command execution"
      pattern: "storage\\.set_item.*virtualmac_terminal"
    - from: "src/terminal.rs"
      to: "localStorage"
      via: "load_from_storage on mount"
      pattern: "storage\\.get_item.*virtualmac_terminal"
---

<objective>
Add localStorage persistence to Terminal for command history and current working directory.

Purpose: Extend the Phase 1 persistence pattern to Terminal. Users can close the browser, return later, and have their command history and last cwd preserved.

Output: Terminal with persisted command history (up/down arrow recall) and cwd that survives page refresh.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-terminal-textedit-persistence/02-RESEARCH.md
@src/calculator.rs (lines 1-85 - reference persistence pattern)
@src/terminal.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add persistence infrastructure to Terminal</name>
  <files>src/terminal.rs</files>
  <action>
Add TerminalState struct and persistence following the Calculator pattern exactly:

1. Add imports at top of file:
   ```rust
   use serde::{Deserialize, Serialize};
   ```

2. Create constants and serializable state struct:
   ```rust
   #[allow(dead_code)]
   const STORAGE_KEY: &str = "virtualmac_terminal";
   #[allow(dead_code)]
   const CURRENT_SCHEMA_VERSION: u32 = 1;
   const MAX_COMMAND_HISTORY: usize = 1000;

   #[derive(Clone, Debug, Serialize, Deserialize)]
   struct TerminalState {
       schema_version: u32,
       command_history: Vec<String>,
       cwd: String,
   }

   impl Default for TerminalState {
       fn default() -> Self {
           Self {
               schema_version: CURRENT_SCHEMA_VERSION,
               command_history: Vec::new(),
               cwd: "/".to_string(),
           }
       }
   }
   ```

3. Add save_to_storage function (platform-gated):
   ```rust
   fn save_to_storage(state: &TerminalState) {
       #[cfg(target_arch = "wasm32")]
       {
           if let Some(window) = web_sys::window() {
               if let Ok(Some(storage)) = window.local_storage() {
                   if let Ok(json) = serde_json::to_string(state) {
                       let _ = storage.set_item(STORAGE_KEY, &json);
                   }
               }
           }
       }
       #[cfg(not(target_arch = "wasm32"))]
       {
           let _ = state;
       }
   }
   ```

4. Add load_from_storage function (platform-gated, graceful degradation):
   ```rust
   fn load_from_storage() -> TerminalState {
       #[cfg(target_arch = "wasm32")]
       {
           if let Some(window) = web_sys::window() {
               if let Ok(Some(storage)) = window.local_storage() {
                   if let Ok(Some(json)) = storage.get_item(STORAGE_KEY) {
                       if let Ok(state) = serde_json::from_str::<TerminalState>(&json) {
                           return state;
                       }
                   }
               }
           }
       }
       TerminalState::default()
   }
   ```

5. In Terminal component, initialize terminal_state from storage:
   ```rust
   let (terminal_state, set_terminal_state) = signal(load_from_storage());
   ```

6. Initialize existing signals from terminal_state:
   - Change `command_history` to be derived from terminal_state:
     ```rust
     let (command_history, set_command_history) = signal(terminal_state.get_untracked().command_history);
     ```
   - Change `cwd` initialization:
     ```rust
     let (cwd, set_cwd) = signal(terminal_state.get_untracked().cwd);
     ```

7. Update execute_command to save on command execution:
   - After adding command to command_history (around line 139-144), also update terminal_state:
     ```rust
     set_command_history.update(|h| {
         if h.last().map(|s| s.as_str()) != Some(&trimmed) {
             h.push(trimmed.clone());
             // Enforce limit
             if h.len() > MAX_COMMAND_HISTORY {
                 h.remove(0);
             }
         }
     });
     // Persist command history
     set_terminal_state.update(|state| {
         state.command_history = command_history.get_untracked();
     });
     ```

8. Update cd command handler to persist cwd changes:
   - After `set_cwd.set(new_path.clone())`, add:
     ```rust
     set_terminal_state.update(|state| {
         state.cwd = new_path.clone();
     });
     ```

9. Add Effect for auto-save on terminal_state changes:
   ```rust
   Effect::new(move |_| {
       let current_state = terminal_state.get();
       save_to_storage(&current_state);
   });
   ```

IMPORTANT:
- Do NOT persist display output history (the `history` signal with terminal lines) - matches real Terminal behavior
- Save on command execution (Enter key), not on every input change
- Enforce MAX_COMMAND_HISTORY limit when adding commands
  </action>
  <verify>
Run `cargo build --all-targets --all-features` - should compile without errors.
Run `cargo clippy --all-targets --all-features -- -D warnings` - should pass.
Run `cargo fmt --all` - should format code.
  </verify>
  <done>
TerminalState struct exists with schema_version, command_history, and cwd fields. save_to_storage and load_from_storage functions exist. Command history limited to 1000 entries. cwd persisted on cd command. terminal_state signal initialized from storage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify Terminal persistence works end-to-end</name>
  <files>src/terminal.rs</files>
  <action>
Manual verification steps (no code changes needed, just testing):

1. Run `trunk serve` and open the app in browser
2. Open Terminal app
3. Execute several commands: `ls`, `cd /Documents`, `pwd`, `echo hello`
4. Note the current directory and commands entered
5. Refresh the page (F5 or Cmd+R)
6. Open Terminal again
7. Verify:
   - The cwd is restored (should still be /Documents)
   - Press up arrow - should show last command
   - Continue pressing up - should cycle through history

If any issues found, fix them in the terminal.rs file.

Common issues to check:
- Command history not loading: Check load_from_storage is called before signal creation
- cwd not persisting: Check set_terminal_state.update is called after set_cwd
- History overflow: Try entering 1001 commands (or check code logic)

After verification, run final checks:
- `cargo fmt --all`
- `cargo clippy --all-targets --all-features -- -D warnings`
- `cargo build --all-targets --all-features`
- `cargo test --all-features`
  </action>
  <verify>
1. Page refresh preserves cwd
2. Page refresh preserves command history (up/down arrows work)
3. No console errors related to localStorage
4. All cargo checks pass
  </verify>
  <done>
Terminal command history survives page refresh. Terminal cwd survives page refresh. Up/down arrow navigation works with persisted history. All Rust pre-commit checks pass.
  </done>
</task>

</tasks>

<verification>
Phase-level verification for Terminal:

1. **Command history persists:**
   - Open Terminal, run `echo test1`, `echo test2`, `echo test3`
   - Refresh page
   - Open Terminal, press up arrow three times
   - Commands appear in reverse order: test3, test2, test1

2. **CWD persists:**
   - Open Terminal, run `cd /Documents`
   - Run `pwd` to verify
   - Refresh page
   - Open Terminal, run `pwd`
   - Should show `/Documents`

3. **History limit enforced:**
   - Check code has MAX_COMMAND_HISTORY = 1000
   - Verify truncation logic removes oldest first

4. **Output does NOT persist:**
   - Run some commands that produce output
   - Refresh page
   - Terminal starts fresh (only "Last login" message)

5. **Graceful degradation:**
   - Clear localStorage: `localStorage.removeItem('virtualmac_terminal')`
   - Refresh page - Terminal works with defaults (cwd=/, empty history)
   - No console errors

6. **Code quality:**
   - `cargo fmt --all`
   - `cargo clippy --all-targets --all-features -- -D warnings`
   - `cargo build --all-targets --all-features`
   - `cargo test --all-features`
</verification>

<success_criteria>
- Terminal command history (up/down arrows) persists across page refresh
- Terminal cwd persists across page refresh
- History limited to 1000 commands
- Output history does NOT persist
- State stored in `virtualmac_terminal` localStorage key
- Graceful fallback to defaults if storage unavailable/corrupted
- All Rust pre-commit checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-terminal-textedit-persistence/02-01-SUMMARY.md`
</output>
