---
phase: 01-calculator-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/calculator.rs
  - styles.css
autonomous: true

must_haves:
  truths:
    - "Calculator memory value persists across page refresh"
    - "User can store a value with M+ button"
    - "User can subtract from memory with M- button"
    - "User can recall memory with MR button"
    - "User can clear memory with MC button"
    - "Memory indicator shows when memory has a stored value"
    - "Calculator gracefully handles missing or corrupted storage"
  artifacts:
    - path: "src/calculator.rs"
      provides: "CalculatorState struct, save/load functions, memory buttons"
      contains: "CalculatorState"
      min_lines: 500
    - path: "styles.css"
      provides: "Memory button styling and memory indicator"
      contains: "calc-btn.memory"
  key_links:
    - from: "src/calculator.rs"
      to: "localStorage"
      via: "save_to_storage Effect"
      pattern: "storage\\.set_item.*virtualmac_calculator"
    - from: "src/calculator.rs"
      to: "localStorage"
      via: "load_from_storage on mount"
      pattern: "storage\\.get_item.*virtualmac_calculator"
---

<objective>
Add memory functionality and localStorage persistence to Calculator.

Purpose: Establish the persistence pattern that all subsequent apps will follow. Calculator is the simplest app, making it ideal for validating the pattern before extending to Terminal/TextEdit.

Output: Calculator with working M+/M-/MR/MC buttons and memory value that persists across page refresh.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
@src/calculator.rs
@src/notes.rs (lines 78-120 - reference persistence pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add persistence infrastructure and memory state</name>
  <files>src/calculator.rs</files>
  <action>
Add CalculatorState struct and persistence following the Notes pattern exactly:

1. Add imports at top of file:
   ```rust
   use serde::{Deserialize, Serialize};
   ```

2. Create serializable state struct with schema version:
   ```rust
   const STORAGE_KEY: &str = "virtualmac_calculator";
   const CURRENT_SCHEMA_VERSION: u32 = 1;

   #[derive(Clone, Debug, Serialize, Deserialize, Default)]
   struct CalculatorState {
       schema_version: u32,
       memory: Option<f64>,
   }

   impl CalculatorState {
       fn new() -> Self {
           Self {
               schema_version: CURRENT_SCHEMA_VERSION,
               memory: None,
           }
       }
   }
   ```

3. Add save_to_storage function (platform-gated):
   ```rust
   fn save_to_storage(state: &CalculatorState) {
       #[cfg(target_arch = "wasm32")]
       {
           if let Some(window) = web_sys::window() {
               if let Ok(Some(storage)) = window.local_storage() {
                   if let Ok(json) = serde_json::to_string(state) {
                       let _ = storage.set_item(STORAGE_KEY, &json);
                   }
               }
           }
       }
       #[cfg(not(target_arch = "wasm32"))]
       {
           let _ = state;
       }
   }
   ```

4. Add load_from_storage function (platform-gated, graceful degradation):
   ```rust
   fn load_from_storage() -> CalculatorState {
       #[cfg(target_arch = "wasm32")]
       {
           if let Some(window) = web_sys::window() {
               if let Ok(Some(storage)) = window.local_storage() {
                   if let Ok(Some(json)) = storage.get_item(STORAGE_KEY) {
                       if let Ok(state) = serde_json::from_str::<CalculatorState>(&json) {
                           return state;
                       }
                   }
               }
           }
       }
       CalculatorState::new()
   }
   ```

5. In Calculator component, add memory signal initialized from storage:
   ```rust
   let (calc_state, set_calc_state) = signal(load_from_storage());
   ```

6. Add Effect for auto-save on calc_state changes:
   ```rust
   Effect::new(move |_| {
       let current_state = calc_state.get();
       save_to_storage(&current_state);
   });
   ```

7. Add memory operation closures:
   - `memory_add`: Add current display value to memory (M+ = memory + current)
   - `memory_subtract`: Subtract current display value from memory (M- = memory - current)
   - `memory_recall`: Set display to memory value (MR)
   - `memory_clear`: Clear memory to None (MC)

   Each memory operation should update calc_state, which triggers the save Effect.

IMPORTANT: Do NOT persist display, stored_value, current_op, or clear_on_next - those are transient calculation state.
  </action>
  <verify>
Run `cargo build --all-targets --all-features` - should compile without errors.
Run `cargo clippy --all-targets --all-features -- -D warnings` - should pass.
  </verify>
  <done>
CalculatorState struct exists with schema_version and memory fields. save_to_storage and load_from_storage functions exist. calc_state signal initialized from storage. Effect auto-saves on changes. Memory operation closures defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add memory buttons to UI and styling</name>
  <files>src/calculator.rs, styles.css</files>
  <action>
1. In Calculator component view, add a memory button row above the existing function row:
   ```rust
   <div class="calc-buttons">
       // NEW: Memory row
       <button
           class=move || if calc_state.get().memory.is_some() { "calc-btn memory has-value" } else { "calc-btn memory" }
           on:click=move |_| memory_clear()
       >"MC"</button>
       <button
           class=move || if calc_state.get().memory.is_some() { "calc-btn memory has-value" } else { "calc-btn memory" }
           on:click=move |_| memory_add()
       >"M+"</button>
       <button
           class=move || if calc_state.get().memory.is_some() { "calc-btn memory has-value" } else { "calc-btn memory" }
           on:click=move |_| memory_subtract()
       >"M−"</button>
       <button
           class=move || if calc_state.get().memory.is_some() { "calc-btn memory has-value" } else { "calc-btn memory" }
           on:click=move |_| memory_recall()
       >"MR"</button>

       // EXISTING: Function row (AC, +/-, %, ÷)
       ...
   ```

2. In styles.css, add memory button styles in the Calculator section:
   ```css
   .calc-btn.memory {
       background: #505050;
       color: #fff;
       font-size: 18px;
   }

   .calc-btn.memory:hover {
       background: #606060;
   }

   .calc-btn.memory.has-value {
       color: #ffa500;
   }
   ```

   The `has-value` class provides visual feedback that memory contains a stored value.

3. Update calculator grid to accommodate 5 rows of 4 buttons (add memory row):
   - If using CSS grid, update grid-template-rows or adjust layout
   - Ensure memory buttons fit the existing 4-column layout

4. Add keyboard shortcuts for memory operations (optional but nice):
   - 'm' for MR (memory recall - most common operation)
   - Update the keyboard event listener in the existing Effect

IMPORTANT: Use M- symbol as "M−" (minus sign U+2212) for consistency with existing calculator symbols.
  </action>
  <verify>
Run `trunk serve` and open Calculator app.
1. MC/M+/M-/MR buttons visible above AC row
2. Enter "42", press M+ - memory indicator turns orange
3. Press AC to clear, press MR - display shows "42"
4. Press M- with "10" on display - memory now 32
5. Press MR - display shows "32"
6. Press MC - memory indicator turns white
7. Refresh page - press MR - display shows "32" (persisted!)
  </verify>
  <done>
Memory buttons (MC, M+, M-, MR) visible in calculator UI. Buttons show orange color when memory has value. Memory value persists across page refresh.
  </done>
</task>

</tasks>

<verification>
Phase-level verification:

1. **Memory functionality works:**
   - M+ adds display value to memory
   - M- subtracts display value from memory
   - MR recalls memory to display
   - MC clears memory

2. **Persistence works:**
   - Open Calculator, store value with M+
   - Refresh page
   - Press MR - stored value appears

3. **Graceful degradation:**
   - Clear localStorage: `localStorage.removeItem('virtualmac_calculator')`
   - Refresh page - Calculator works normally with no memory
   - No console errors

4. **Code quality:**
   - `cargo fmt --all`
   - `cargo clippy --all-targets --all-features -- -D warnings`
   - `cargo build --all-targets --all-features`
   - `cargo test --all-features`
</verification>

<success_criteria>
- Calculator memory (M+/M-/MR/MC) fully functional
- Memory value persists in `virtualmac_calculator` localStorage key
- Memory indicator shows orange when value stored
- No persistence of transient state (display, current operation)
- Graceful fallback to defaults if storage unavailable/corrupted
- All Rust pre-commit checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-calculator-persistence/01-01-SUMMARY.md`
</output>
