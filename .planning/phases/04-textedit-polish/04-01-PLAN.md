---
phase: 04-textedit-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/textedit.rs
  - styles.css
autonomous: true

must_haves:
  truths:
    - "User can toggle bold/italic/underline formatting"
    - "User can select font family from dropdown"
    - "User can change font size via selector"
    - "User can align text left/center/right/justify"
    - "Formatting buttons show active state based on cursor position"
  artifacts:
    - path: "src/textedit.rs"
      provides: "TextEdit component with full toolbar"
      contains: "queryCommandState"
    - path: "styles.css"
      provides: "Toolbar button styling"
      contains: "textedit-select"
  key_links:
    - from: "src/textedit.rs"
      to: "document.execCommand"
      via: "wasm_bindgen extern"
      pattern: "execCommand"
    - from: "src/textedit.rs"
      to: "document.queryCommandState"
      via: "wasm_bindgen extern"
      pattern: "queryCommandState"
---

<objective>
Add complete formatting toolbar to TextEdit with font family dropdown, font size selector, B/I/U buttons, and alignment controls.

Purpose: Cover REQ-004.1, REQ-004.3, REQ-004.4, REQ-004.5, REQ-004.6 - the core formatting controls users expect in a text editor.
Output: TextEdit with functional toolbar matching macOS TextEdit's formatting capabilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-textedit-polish/04-RESEARCH.md
@src/textedit.rs
@styles.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add queryCommandState and underline button</name>
  <files>src/textedit.rs</files>
  <action>
    1. Add `queryCommandState` extern declaration alongside existing `execCommand`:
       ```rust
       #[wasm_bindgen(js_namespace = document)]
       fn queryCommandState(command: &str) -> bool;
       ```

    2. Add underline state signal: `let (is_underline, set_is_underline) = signal(false);`

    3. Add toggle_underline handler using same pattern as bold/italic:
       ```rust
       let toggle_underline = move |_: MouseEvent| {
           execCommand("underline", false, "");
           set_is_underline.update(|u| *u = !*u);
       };
       ```

    4. Add underline button to toolbar after italic button:
       ```rust
       <button
           class=move || if is_underline.get() { "textedit-btn active" } else { "textedit-btn" }
           on:click=toggle_underline
           title="Underline"
       >
           <span style="text-decoration: underline">"U"</span>
       </button>
       ```

    5. Add selection change listener to update formatting state. Create an effect that queries command state:
       - For now, update states in the toggle handlers (queryCommandState will be used in Task 2 for selection tracking)
  </action>
  <verify>Run `trunk serve`, open TextEdit from dock, test:
    - Bold (B) button toggles and shows active state
    - Italic (I) button toggles and shows active state
    - Underline (U) button toggles and shows active state
    - All three formatting commands apply to selected text</verify>
  <done>TextEdit has B/I/U buttons that toggle formatting and show active state</done>
</task>

<task type="auto">
  <name>Task 2: Add font family dropdown and font size selector</name>
  <files>src/textedit.rs, styles.css</files>
  <action>
    1. In textedit.rs, add font family signal and web-safe font list:
       ```rust
       let (font_family, set_font_family) = signal("Helvetica Neue".to_string());

       // Web-safe fonts that work across browsers
       const FONTS: &[(&str, &str)] = &[
           ("Helvetica Neue", "Helvetica Neue, Helvetica, Arial, sans-serif"),
           ("Arial", "Arial, Helvetica, sans-serif"),
           ("Times New Roman", "Times New Roman, Times, serif"),
           ("Georgia", "Georgia, serif"),
           ("Courier New", "Courier New, Courier, monospace"),
           ("Verdana", "Verdana, Geneva, sans-serif"),
           ("Trebuchet MS", "Trebuchet MS, sans-serif"),
           ("Monaco", "Monaco, Consolas, monospace"),
       ];
       ```

    2. Create font change handler:
       ```rust
       let on_font_change = move |e: web_sys::Event| {
           let target = e.target().unwrap();
           let select = target.dyn_into::<web_sys::HtmlSelectElement>().unwrap();
           let value = select.value();
           set_font_family.set(value.clone());
           execCommand("fontName", false, &value);
       };
       ```

    3. Replace current A-/A+ font size buttons with a proper dropdown. Create font size list:
       ```rust
       const FONT_SIZES: &[u32] = &[9, 10, 11, 12, 14, 16, 18, 24, 30, 36, 48, 64, 72];
       ```

    4. For font size, use CSS font-size on container (execCommand fontSize only takes 1-7):
       - Keep font_size signal but use it for CSS styling
       - Create on_size_change handler that updates the signal

    5. Add toolbar UI (replace existing font controls):
       ```rust
       // Font family dropdown
       <select
           class="textedit-select"
           on:change=on_font_change
       >
           {FONTS.iter().map(|(name, _stack)| {
               view! { <option value={*name}>{*name}</option> }
           }).collect_view()}
       </select>

       // Font size dropdown
       <select
           class="textedit-select textedit-select-size"
           on:change=on_size_change
       >
           {FONT_SIZES.iter().map(|size| {
               view! { <option value={size.to_string()} selected={*size == font_size.get()}>{size.to_string()}</option> }
           }).collect_view()}
       </select>
       ```

    6. Add use statement for web_sys: `use web_sys::wasm_bindgen::JsCast;`

    7. In styles.css, add select styling:
       ```css
       .textedit-select {
           height: 24px;
           padding: 0 8px;
           border: 1px solid #c8c8c8;
           background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 100%);
           border-radius: 4px;
           font-size: 12px;
           color: #333;
           cursor: pointer;
           outline: none;
           font-family: inherit;
       }

       .textedit-select:hover {
           border-color: #b0b0b0;
       }

       .textedit-select:focus {
           border-color: #007aff;
           box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
       }

       .textedit-select-size {
           width: 60px;
       }
       ```
  </action>
  <verify>Run `trunk serve`, test:
    - Font family dropdown shows 8 font options
    - Selecting a font applies it to selected text
    - Font size dropdown shows common sizes (9-72)
    - Selecting a size changes the document font size
    - Dropdowns have macOS-style appearance</verify>
  <done>TextEdit has functional font family and size dropdowns with proper styling</done>
</task>

<task type="auto">
  <name>Task 3: Add text alignment buttons</name>
  <files>src/textedit.rs, styles.css</files>
  <action>
    1. Add alignment state signal:
       ```rust
       let (alignment, set_alignment) = signal("left".to_string());
       ```

    2. Create alignment handler:
       ```rust
       let set_align = move |align: &'static str| {
           move |e: MouseEvent| {
               e.prevent_default(); // Prevent focus loss
               let cmd = match align {
                   "left" => "justifyLeft",
                   "center" => "justifyCenter",
                   "right" => "justifyRight",
                   "justify" => "justifyFull",
                   _ => "justifyLeft",
               };
               execCommand(cmd, false, "");
               set_alignment.set(align.to_string());
           }
       };
       ```

    3. Add alignment buttons group after formatting buttons:
       ```rust
       <div class="textedit-toolbar-separator"></div>
       <div class="textedit-toolbar-group">
           <button
               class=move || if alignment.get() == "left" { "textedit-btn active" } else { "textedit-btn" }
               on:mousedown=set_align("left")
               title="Align Left"
           >
               <span class="textedit-icon">{"\u{2261}"}</span>  // Using Unicode for alignment icons
           </button>
           <button
               class=move || if alignment.get() == "center" { "textedit-btn active" } else { "textedit-btn" }
               on:mousedown=set_align("center")
               title="Align Center"
           >
               <span class="textedit-icon">{"\u{2261}"}</span>
           </button>
           <button
               class=move || if alignment.get() == "right" { "textedit-btn active" } else { "textedit-btn" }
               on:mousedown=set_align("right")
               title="Align Right"
           >
               <span class="textedit-icon">{"\u{2261}"}</span>
           </button>
           <button
               class=move || if alignment.get() == "justify" { "textedit-btn active" } else { "textedit-btn" }
               on:mousedown=set_align("justify")
               title="Justify"
           >
               <span class="textedit-icon">{"\u{2261}"}</span>
           </button>
       </div>
       ```

    4. Use on:mousedown with prevent_default instead of on:click to prevent contenteditable focus loss (per research pitfall #5).

    5. For alignment icons, use simple text representations or CSS:
       - Left align: lines left-aligned
       - Center: lines centered
       - Right: lines right-aligned
       - Justify: lines full-width

       Add CSS for the icons:
       ```css
       .textedit-icon {
           font-size: 11px;
           line-height: 1;
       }

       /* Alignment icon representations using CSS */
       .textedit-align-left::before { content: ""; display: block; width: 14px; height: 2px; background: currentColor; margin: 2px 0; }
       .textedit-align-left::after { content: ""; display: block; width: 10px; height: 2px; background: currentColor; }
       ```

       Or use Unicode/text: Left="<", Center="=", Right=">", Justify="#"

       For simplicity, use descriptive single letters: L, C, R, J (or use the Unicode alignment characters if they render well).
  </action>
  <verify>Run `trunk serve`, test:
    - Four alignment buttons visible (left, center, right, justify)
    - Clicking alignment button aligns current paragraph
    - Active alignment button shows highlighted state
    - Clicking alignment buttons does NOT deselect text (focus preserved)</verify>
  <done>TextEdit has alignment buttons that work without losing text selection</done>
</task>

</tasks>

<verification>
1. Run `trunk serve` and open TextEdit
2. Verify toolbar has: Font dropdown | Size dropdown | B I U | Alignment buttons (4)
3. Test each formatting option on selected text
4. Verify active states update correctly
5. Verify no console errors
</verification>

<success_criteria>
- REQ-004.1 (toolbar) partially complete - core controls present
- REQ-004.3 (font family) complete - dropdown with web-safe fonts
- REQ-004.4 (font size) complete - size selector working
- REQ-004.5 (B/I/U) complete - all three buttons functional
- REQ-004.6 (alignment) complete - all four alignment options work
</success_criteria>

<output>
After completion, create `.planning/phases/04-textedit-polish/04-01-SUMMARY.md`
</output>
