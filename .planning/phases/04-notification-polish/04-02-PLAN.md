---
phase: 04-notification-polish
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/notification.rs
autonomous: false

must_haves:
  truths:
    - "Notifications play exit animation before removal from DOM"
    - "Hovering pauses the auto-dismiss timer"
    - "Clicking anywhere on notification dismisses it"
    - "Only 3 notifications visible at a time"
    - "App icon displays in notification"
  artifacts:
    - path: "src/notification.rs"
      provides: "Notification state management with exit animation"
      contains: "exiting"
  key_links:
    - from: "src/notification.rs"
      to: "styles.css"
      via: "exiting class name"
      pattern: "exiting"
    - from: "src/notification.rs"
      to: "web_sys::window"
      via: "clearTimeout for hover pause"
      pattern: "clear_timeout"
---

<objective>
Add Rust state management for exit animations, hover-to-pause, and click-to-dismiss interactions.

Purpose: CSS animations are ready from Plan 01, but Rust must coordinate when to apply the `exiting` class and manage timer cancellation. This plan wires up the behavior.

Output: Updated notification.rs with exit state, hover pause, click dismiss, and icon rendering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-notification-polish/04-CONTEXT.md
@.planning/phases/04-notification-polish/04-RESEARCH.md
@.planning/phases/04-notification-polish/04-01-SUMMARY.md
@src/notification.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add exit animation state and delayed removal</name>
  <files>src/notification.rs</files>
  <action>
Modify notification.rs to support exit animations:

1. Add `exiting` field to `Notification` struct:
```rust
pub struct Notification {
    pub id: usize,
    pub title: String,
    pub message: String,
    pub icon: Option<String>,
    pub exiting: bool, // NEW: tracks exit animation state
}
```

2. Initialize `exiting: false` when creating notification in `show()`

3. Modify the `dismiss()` method to set `exiting = true` first, then schedule actual removal after 400ms (matching CSS animation duration):
```rust
pub fn dismiss(&self, id: usize) {
    // Set exiting state (triggers CSS animation)
    self.notifications.update(|n| {
        if let Some(notif) = n.iter_mut().find(|notif| notif.id == id) {
            notif.exiting = true;
        }
    });

    // Actually remove after animation completes
    #[cfg(target_arch = "wasm32")]
    {
        use wasm_bindgen::closure::Closure;
        use wasm_bindgen::JsCast;

        let notifications = self.notifications;
        let cb = Closure::once(Box::new(move || {
            notifications.update(|n| n.retain(|notif| notif.id != id));
        }) as Box<dyn FnOnce()>);

        if let Some(window) = web_sys::window() {
            let _ = window.set_timeout_with_callback_and_timeout_and_arguments_0(
                cb.as_ref().unchecked_ref(),
                400, // Match CSS animation duration
            );
            cb.forget();
        }
    }

    // Non-wasm fallback (immediate removal)
    #[cfg(not(target_arch = "wasm32"))]
    {
        self.notifications.update(|n| n.retain(|notif| notif.id != id));
    }
}
```

4. In `NotificationItem` component, conditionally apply the `exiting` class:
```rust
view! {
    <div class=move || {
        let base = "notification";
        if notification.exiting { format!("{} exiting", base) } else { base.to_string() }
    }>
    // ... rest of content
    </div>
}
```

Note: This requires passing the full notification or its `exiting` state to NotificationItem. Update the component signature and For loop accordingly.
  </action>
  <verify>Run `cargo clippy --all-targets --all-features -- -D warnings` to confirm no errors. Then `trunk build` to verify compilation.</verify>
  <done>Dismiss sets exiting=true, waits 400ms, then removes. NotificationItem applies "exiting" class when appropriate.</done>
</task>

<task type="auto">
  <name>Task 2: Add hover pause and click-to-dismiss</name>
  <files>src/notification.rs</files>
  <action>
Add hover-to-pause and click-anywhere-to-dismiss:

1. Store timeout handle in Notification struct for cancellation:
```rust
pub struct Notification {
    pub id: usize,
    pub title: String,
    pub message: String,
    pub icon: Option<String>,
    pub exiting: bool,
    pub timeout_handle: Option<i32>, // NEW: for timer cancellation
}
```

2. Update `show()` to store the timeout handle:
```rust
let handle = window.set_timeout_with_callback_and_timeout_and_arguments_0(
    cb.as_ref().unchecked_ref(),
    5000,
)?;

// Store handle in notification for later cancellation
self.notifications.update(|n| {
    if let Some(notif) = n.iter_mut().find(|notif| notif.id == id) {
        notif.timeout_handle = Some(handle);
    }
});
```

3. Add methods to pause/resume auto-dismiss:
```rust
pub fn pause_auto_dismiss(&self, id: usize) {
    #[cfg(target_arch = "wasm32")]
    {
        self.notifications.update(|n| {
            if let Some(notif) = n.iter_mut().find(|notif| notif.id == id) {
                if let Some(handle) = notif.timeout_handle.take() {
                    if let Some(window) = web_sys::window() {
                        window.clear_timeout_with_handle(handle);
                    }
                }
            }
        });
    }
}

pub fn resume_auto_dismiss(&self, id: usize) {
    #[cfg(target_arch = "wasm32")]
    {
        // Restart the 5-second timer
        // ... similar to show() timer setup but for existing notification
    }
}
```

4. In `NotificationItem`, add hover handlers and click-to-dismiss:
```rust
let on_hover_start = move |_| {
    notification_state.pause_auto_dismiss(id);
};

let on_hover_end = move |_| {
    notification_state.resume_auto_dismiss(id);
};

let on_click = move |_| {
    notification_state.dismiss(id);
};

view! {
    <div
        class=...
        on:mouseenter=on_hover_start
        on:mouseleave=on_hover_end
        on:click=on_click
    >
    // Remove the separate dismiss button - clicking anywhere dismisses
    </div>
}
```

5. Update NotificationItem to accept and display icon:
```rust
#[component]
fn NotificationItem(
    id: usize,
    title: String,
    message: String,
    icon: Option<String>,
    exiting: bool,
) -> impl IntoView {
    // ...
    let icon_display = icon.unwrap_or_else(|| "".to_string());
    // Use icon_display in the notification-app-icon div
}
```

Note: Keep the dismiss button visible on hover (current behavior) as secondary option, but clicking anywhere should work.
  </action>
  <verify>Run `cargo clippy --all-targets --all-features -- -D warnings` and `trunk build`.</verify>
  <done>Hovering pauses auto-dismiss timer. Clicking notification dismisses it. Icon prop renders in notification.</done>
</task>

<task type="auto">
  <name>Task 3: Add max 3 visible notifications</name>
  <files>src/notification.rs</files>
  <action>
Limit visible notifications to 3 (per CONTEXT.md):

1. In `NotificationContainer`, only render the first 3 non-exiting notifications:
```rust
view! {
    <div class="notification-container">
        <For
            each=move || {
                notification_state.notifications.get()
                    .into_iter()
                    .filter(|n| !n.exiting)
                    .take(3)
                    .collect::<Vec<_>>()
            }
            key=|n| n.id
            children=move |notification| {
                // ... render NotificationItem
            }
        />
    </div>
}
```

Note: Notifications beyond the first 3 remain in state but are not rendered. When one of the visible 3 dismisses (exits), the 4th becomes visible and animates in automatically (since it's newly rendered, it gets the entrance animation).

Alternative approach if the above causes issues with Leptos reactivity: Use CSS to hide beyond 3rd:
```css
.notification:nth-child(n+4) {
    display: none;
}
```
But the Rust approach is cleaner as it avoids rendering hidden DOM elements.
  </action>
  <verify>Create 4+ notifications rapidly and verify only 3 are visible. Dismiss one and verify the 4th appears with entrance animation.</verify>
  <done>Max 3 notifications visible at a time. Queued notifications appear when space opens.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete notification polish: entrance/exit animations, hover pause, click dismiss, max 3 visible, app icon</what-built>
  <how-to-verify>
1. Start the app: `trunk serve`
2. Open http://localhost:8080
3. Trigger a notification (e.g., via console or by causing a schema migration notification)
   - If no easy trigger: Temporarily add a button to call `notification_state.show("Test", "Test message")`
4. Verify entrance animation: Notification slides in smoothly from right (400ms ease-out)
5. Verify hover: Hover over notification - timer should pause (it won't auto-dismiss while hovering)
6. Verify hover visual: Subtle brightness increase on hover
7. Verify click dismiss: Click anywhere on notification - it should slide out to right (400ms)
8. Test multiple notifications:
   - Trigger 4+ notifications rapidly
   - Only 3 should be visible
   - Dismiss one, the 4th should slide in
9. Verify stacking: When one dismisses, remaining notifications should smoothly collapse upward
10. Verify shadow: Should be soft and diffuse (macOS Big Sur style)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cargo fmt --all`
2. `cargo clippy --all-targets --all-features -- -D warnings` passes
3. `trunk build` succeeds
4. Human verification of visual behavior
</verification>

<success_criteria>
- Notifications slide in with 400ms ease-out animation
- Notifications slide out with 400ms ease-in animation when dismissed
- Hovering pauses auto-dismiss timer
- Clicking anywhere on notification dismisses it
- Max 3 notifications visible at once
- 4th+ notification appears when space opens
- Stacking collapse is smooth
- Shadow is soft and diffuse
- App icon renders (or fallback gear icon)
</success_criteria>

<output>
After completion, create `.planning/phases/04-notification-polish/04-02-SUMMARY.md`
</output>
