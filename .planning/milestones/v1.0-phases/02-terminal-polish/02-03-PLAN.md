---
phase: 02-terminal-polish
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/terminal.rs
autonomous: true

must_haves:
  truths:
    - "User can press up arrow to see previous command"
    - "User can press down arrow to navigate forward in history"
    - "User can press Tab to complete file/directory names"
    - "Tab completion appends / for directories"
  artifacts:
    - path: "src/terminal.rs"
      provides: "Command history and tab completion"
      contains: "ArrowUp"
  key_links:
    - from: "src/terminal.rs"
      to: "keyboard events"
      via: "on_keydown handler"
      pattern: "ArrowUp|ArrowDown|Tab"
---

<objective>
Add command history navigation (up/down arrows) and tab completion for file paths.

Purpose: Make the terminal feel like a real shell with history recall and path completion - essential UX features.
Output: Terminal with working command history and tab completion.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-terminal-polish/02-RESEARCH.md
@src/terminal.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add command history navigation</name>
  <files>src/terminal.rs</files>
  <action>
    Add command history with up/down arrow navigation:

    1. Add new signals for history tracking (after existing signals):
       ```rust
       let (command_history, set_command_history) = signal::<Vec<String>>(Vec::new());
       let (history_index, set_history_index) = signal::<Option<usize>>(None);
       let (saved_input, set_saved_input) = signal::<String>(String::new());
       ```

    2. Modify execute_command to add commands to history:
       ```rust
       let execute_command = move |cmd: String| {
           let trimmed = cmd.trim().to_string();
           if trimmed.is_empty() {
               return;
           }

           // Add to command history (not display history)
           set_command_history.update(|h| {
               // Don't add duplicates of the last command
               if h.last().map(|s| s.as_str()) != Some(&trimmed) {
                   h.push(trimmed.clone());
               }
           });
           // Reset history navigation state
           set_history_index.set(None);
           set_saved_input.set(String::new());

           // ... rest of execute_command logic ...
       };
       ```

    3. Update on_keydown to handle ArrowUp, ArrowDown, and Enter:
       ```rust
       let on_keydown = move |e: KeyboardEvent| {
           match e.key().as_str() {
               "ArrowUp" => {
                   e.prevent_default();
                   let hist = command_history.get();
                   if hist.is_empty() {
                       return;
                   }

                   let new_index = match history_index.get() {
                       None => {
                           // First up arrow - save current input, go to last command
                           set_saved_input.set(input.get());
                           hist.len().saturating_sub(1)
                       }
                       Some(idx) if idx > 0 => idx - 1,
                       Some(idx) => idx, // Already at oldest
                   };

                   set_history_index.set(Some(new_index));
                   if let Some(cmd) = hist.get(new_index) {
                       set_input.set(cmd.clone());
                   }
               }
               "ArrowDown" => {
                   e.prevent_default();
                   let hist = command_history.get();

                   match history_index.get() {
                       Some(idx) if idx + 1 < hist.len() => {
                           // Move forward in history
                           let new_idx = idx + 1;
                           set_history_index.set(Some(new_idx));
                           if let Some(cmd) = hist.get(new_idx) {
                               set_input.set(cmd.clone());
                           }
                       }
                       Some(_) => {
                           // At newest history entry - return to saved input
                           set_history_index.set(None);
                           set_input.set(saved_input.get());
                       }
                       None => {} // Not navigating history, do nothing
                   }
               }
               "Enter" => {
                   let cmd = input.get();
                   execute_command(cmd);
                   set_input.set(String::new());
               }
               _ => {}
           }
       };
       ```

    Note: The Vec<String> history is separate from the display output Vec. Command history only stores executed commands, not output.
  </action>
  <verify>
    Run `trunk serve`:
    - Type `ls` and press Enter
    - Type `pwd` and press Enter
    - Press up arrow - shows `pwd`
    - Press up arrow again - shows `ls`
    - Press down arrow - shows `pwd`
    - Press down arrow again - returns to empty input
    - Type "foo" then press up arrow - shows `pwd`
    - Press down arrow - returns to "foo" (saved input restored)
  </verify>
  <done>Up/down arrows navigate command history; current input is preserved when starting navigation</done>
</task>

<task type="auto">
  <name>Task 2: Add tab completion for file paths</name>
  <files>src/terminal.rs</files>
  <action>
    Add tab completion that completes file and directory names:

    1. Add a tab completion helper function (before or inside the component):
       ```rust
       fn find_completions(fs: &VirtualFileSystem, partial: &str, cwd: &str) -> Vec<String> {
           // Determine the directory to search and the prefix to match
           let (search_dir, prefix) = if partial.contains('/') {
               let last_slash = partial.rfind('/').unwrap();
               let dir_part = &partial[..=last_slash];
               let file_part = &partial[last_slash + 1..];

               let resolved_dir = if dir_part.starts_with('/') {
                   dir_part.trim_end_matches('/').to_string()
               } else {
                   format!("{}/{}", cwd, dir_part.trim_end_matches('/'))
               };

               (resolved_dir, file_part.to_string())
           } else {
               (cwd.to_string(), partial.to_string())
           };

           // Get entries in the directory
           let entries = fs.list_dir(&search_dir);

           // Filter entries that start with prefix
           entries
               .iter()
               .filter(|e| e.metadata.name.starts_with(&prefix))
               .map(|e| {
                   if e.is_directory() {
                       format!("{}/", e.metadata.name)
                   } else {
                       e.metadata.name.clone()
                   }
               })
               .collect()
       }
       ```

    2. Add Tab handling to on_keydown (add case before the match's _ arm):
       ```rust
       "Tab" => {
           e.prevent_default();
           let current_input = input.get();
           let current_cwd = cwd.get();

           // Find the word being completed (last space-separated token)
           let parts: Vec<&str> = current_input.split_whitespace().collect();
           if parts.is_empty() {
               return;
           }

           // Determine what we're completing
           let (prefix, completing_word) = if current_input.ends_with(' ') {
               // User typed "cmd " - nothing to complete yet
               return;
           } else if parts.len() == 1 {
               // Completing the command name - skip for now (could add later)
               return;
           } else {
               // Completing an argument (file path)
               let word = parts.last().unwrap();
               let prefix_end = current_input.rfind(word).unwrap();
               (current_input[..prefix_end].to_string(), *word)
           };

           let completions = find_completions(&fs, completing_word, &current_cwd);

           match completions.len() {
               0 => {} // No completions - do nothing (real terminal would beep)
               1 => {
                   // Single completion - replace the word
                   let completed = &completions[0];
                   // Rebuild the input with the completed word
                   let new_input = format!("{}{}", prefix, completed);
                   set_input.set(new_input);
               }
               _ => {
                   // Multiple completions - find common prefix and show options
                   let common = find_common_prefix(&completions);
                   if common.len() > completing_word.len() {
                       // Extend to common prefix
                       let new_input = format!("{}{}", prefix, common);
                       set_input.set(new_input);
                   } else {
                       // Show all options in output
                       set_history.update(|h| {
                           h.push(format!("{}{}", prompt(), current_input));
                           h.push(completions.join("  "));
                       });
                   }
               }
           }
       }
       ```

    3. Add helper function for common prefix:
       ```rust
       fn find_common_prefix(strings: &[String]) -> String {
           if strings.is_empty() {
               return String::new();
           }
           if strings.len() == 1 {
               return strings[0].clone();
           }

           let first = &strings[0];
           let mut prefix_len = first.len();

           for s in &strings[1..] {
               prefix_len = first
                   .chars()
                   .zip(s.chars())
                   .take_while(|(a, b)| a == b)
                   .count()
                   .min(prefix_len);
           }

           first[..prefix_len].to_string()
       }
       ```

    Note: The fs variable needs to be accessible in the closure. If it's not, you may need to clone it into the closure scope.
  </action>
  <verify>
    Run `trunk serve`:
    - Type `ls /Ap` and press Tab - completes to `ls /Applications/`
    - Type `ls /D` and press Tab twice - shows "Desktop/  Documents/  Downloads/" (or extends to common prefix "D")
    - Type `cat /Desktop/N` and press Tab - completes to `cat /Desktop/Notes.txt`
    - Tab on command with no partial (e.g., `ls `) does nothing
  </verify>
  <done>Tab completion works for file paths; directories get trailing slash; multiple matches show options or extend to common prefix</done>
</task>

</tasks>

<verification>
1. `trunk build` compiles without errors
2. Up/down arrows navigate through command history
3. Tab completes file and directory names
4. Directories have trailing "/" in completion
5. Multiple matches either extend to common prefix or show all options
</verification>

<success_criteria>
- Command history stores executed commands (not output)
- Up arrow shows previous command, down arrow shows next
- Current input is saved when entering history navigation
- Tab completes paths based on VirtualFileSystem contents
- Single match auto-completes; multiple matches show options
</success_criteria>

<output>
After completion, create `.planning/phases/02-terminal-polish/02-03-SUMMARY.md`
</output>
