---
phase: 05-finder-polish
plan: 05
type: execute
wave: 2
depends_on: []
files_modified:
  - src/finder.rs
  - src/context_menu.rs
autonomous: true

must_haves:
  truths:
    - "Right-click on Finder content shows context menu"
    - "New Folder action creates a new folder in current directory"
    - "Rename action allows renaming selected item"
    - "Move to Trash action deletes selected item"
  artifacts:
    - path: "src/finder.rs"
      provides: "Context menu handlers for Finder actions"
      contains: "on:contextmenu"
    - path: "src/context_menu.rs"
      provides: "Action callbacks for menu items"
      contains: "on_action"
  key_links:
    - from: "context menu New Folder"
      to: "fs.create_dir"
      via: "action handler"
      pattern: "create_dir"
---

<objective>
Wire context menu actions in Finder to VirtualFileSystem operations.

Purpose: REQ-005.9 requires working context menu actions.
Output: Functional New Folder, Rename, and Move to Trash actions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-finder-polish/05-RESEARCH.md

@src/finder.rs
@src/context_menu.rs
@src/file_system.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add context menu trigger to Finder</name>
  <files>src/finder.rs</files>
  <action>
Add right-click context menu support to Finder items and background.

1. Import context menu types:
```rust
use crate::context_menu::{ContextMenuState, ContextMenuType, show_context_menu};
```

2. Add context menu state at app level or access existing global state. If not available, create local signals:
```rust
let (context_menu_state, set_context_menu_state) = signal(ContextMenuState::default());
```

3. Add contextmenu handler to finder items (icon view, list view, column view):
```rust
on:contextmenu=move |ev: web_sys::MouseEvent| {
    ev.prevent_default();
    show_context_menu(
        set_context_menu_state,
        ev.client_x() as f64,
        ev.client_y() as f64,
        ContextMenuType::FinderItem {
            name: name.clone(),
            is_folder,
        },
    );
}
```

4. Add contextmenu handler to finder content background for "New Folder" option:
```rust
on:contextmenu=move |ev: web_sys::MouseEvent| {
    ev.prevent_default();
    show_context_menu(
        set_context_menu_state,
        ev.client_x() as f64,
        ev.client_y() as f64,
        ContextMenuType::Desktop, // Reuse desktop type for background
    );
}
```

5. Render the ContextMenu component in Finder:
```rust
<ContextMenu state=context_menu_state set_state=set_context_menu_state />
```

Note: Need to handle event propagation so item right-click doesn't bubble to background.
  </action>
  <verify>Run `trunk serve`, right-click in Finder shows context menu</verify>
  <done>Context menu appears on right-click in Finder</done>
</task>

<task type="auto">
  <name>Task 2: Wire New Folder action</name>
  <files>src/finder.rs, src/context_menu.rs</files>
  <action>
Wire the "New Folder" context menu action to create a folder.

Option A: Extend context menu to support action callbacks.
Option B: Use a global action signal that Finder listens to.

**Implementing Option B (simpler):**

1. In finder.rs, create an action handler that runs when context menu is closed with an action:
```rust
let (pending_action, set_pending_action) = signal::<Option<String>>(None);
```

2. Create an effect that handles the action:
```rust
Effect::new(move |_| {
    if let Some(action) = pending_action.get() {
        match action.as_str() {
            "New Folder" => {
                let path = current_path.get();
                // Generate unique name
                let base_name = "untitled folder";
                let mut name = base_name.to_string();
                let mut counter = 1;
                while fs.exists(&format!("{}/{}", path, name)) {
                    counter += 1;
                    name = format!("{} {}", base_name, counter);
                }
                fs.create_dir(&format!("{}/{}", path, name));
            }
            _ => {}
        }
        set_pending_action.set(None);
    }
});
```

3. Modify context_menu.rs to accept an optional action callback:
```rust
#[component]
pub fn ContextMenu(
    state: ReadSignal<ContextMenuState>,
    set_state: WriteSignal<ContextMenuState>,
    #[prop(optional)] on_action: Option<Callback<String>>,
) -> impl IntoView {
    let close_menu_with_action = move |action: &'static str| {
        move |_| {
            if let Some(ref callback) = on_action {
                callback.run(action.to_string());
            }
            set_state.update(|s| s.visible = false);
        }
    };
```

4. Update menu item clicks to call the action callback:
```rust
<div class=class on:click=close_menu_with_action(item.label)>
```

5. Pass the callback from Finder:
```rust
<ContextMenu
    state=context_menu_state
    set_state=set_context_menu_state
    on_action=Callback::new(move |action: String| {
        set_pending_action.set(Some(action));
    })
/>
```
  </action>
  <verify>Run `trunk serve`, right-click background, click "New Folder" - folder appears</verify>
  <done>New Folder action creates untitled folder in current directory</done>
</task>

<task type="auto">
  <name>Task 3: Wire Rename and Move to Trash actions</name>
  <files>src/finder.rs</files>
  <action>
Extend the action handler to support Rename and Move to Trash.

1. For Move to Trash, implement deletion:
```rust
"Move to Trash" => {
    let items = selected_items.get();
    let path = current_path.get();
    for item_name in items {
        let item_path = format!("{}/{}", path, item_name);
        fs.delete(&item_path);
    }
    set_selected_items.set(Vec::new());
}
```

2. For Rename, need to track which item is being renamed and show an input:
```rust
let (renaming_item, set_renaming_item) = signal::<Option<String>>(None);

// In action handler:
"Rename" => {
    let items = selected_items.get();
    if let Some(first) = items.first() {
        set_renaming_item.set(Some(first.clone()));
    }
}
```

3. Modify item rendering to show input when renaming:
```rust
{move || {
    let is_renaming = renaming_item.get().map(|r| r == name).unwrap_or(false);
    if is_renaming {
        view! {
            <input
                type="text"
                class="finder-rename-input"
                prop:value=name.clone()
                on:blur=move |ev| {
                    let new_name = event_target_value(&ev);
                    if !new_name.is_empty() && new_name != name {
                        let old_path = format!("{}/{}", current_path.get(), name);
                        let new_path = format!("{}/{}", current_path.get(), new_name);
                        fs.rename(&old_path, &new_path);
                    }
                    set_renaming_item.set(None);
                }
                on:keydown=move |ev: web_sys::KeyboardEvent| {
                    if ev.key() == "Enter" {
                        ev.target().unwrap().unchecked_ref::<web_sys::HtmlInputElement>().blur().ok();
                    } else if ev.key() == "Escape" {
                        set_renaming_item.set(None);
                    }
                }
                node_ref=rename_input_ref // Auto-focus
            />
        }.into_any()
    } else {
        view! { <div class="finder-item-name">{name}</div> }.into_any()
    }
}}
```

4. Add CSS for rename input:
```css
.finder-rename-input {
    font-size: 11px;
    text-align: center;
    border: 1px solid var(--finder-accent);
    border-radius: 3px;
    padding: 1px 4px;
    background: white;
    outline: none;
    max-width: 80px;
}
```

Note: Auto-focus the input when renaming starts.
  </action>
  <verify>Run `trunk serve`, select item, right-click, test Rename and Move to Trash</verify>
  <done>Rename and Move to Trash actions work on selected items</done>
</task>

</tasks>

<verification>
- `trunk build` completes without errors
- Right-click on background shows context menu with "New Folder"
- Right-click on item shows context menu with Rename, Move to Trash
- "New Folder" creates a new folder
- "Rename" shows inline input, saving renames the item
- "Move to Trash" deletes the selected item(s)
</verification>

<success_criteria>
- REQ-005.9 satisfied: Context menu with working actions
- New Folder, Rename, Move to Trash are functional
- Actions integrate properly with VirtualFileSystem
</success_criteria>

<output>
After completion, create `.planning/phases/05-finder-polish/05-05-SUMMARY.md`
</output>
