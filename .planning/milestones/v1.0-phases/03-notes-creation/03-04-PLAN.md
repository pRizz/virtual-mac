---
phase: 03-notes-creation
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/notes.rs
autonomous: true

must_haves:
  truths:
    - "User can create a new note"
    - "User can delete a note (moves to Recently Deleted)"
    - "User can permanently delete notes from Recently Deleted"
    - "User can create a new folder"
    - "User can rename a folder"
    - "User can delete a custom folder"
    - "Search filters notes by title and content"
  artifacts:
    - path: "src/notes.rs"
      provides: "CRUD operations for notes and folders, search functionality"
      contains: "create_note"
  key_links:
    - from: "src/notes.rs"
      to: "NotesState"
      via: "set_state.update"
      pattern: "set_state\\.update\\(\\|s\\|"
---

<objective>
Implement CRUD operations for notes and folders, plus search functionality.

Purpose: Enable users to create, organize, and find their notes - the core user workflows of the Notes app.

Output: Fully functional note and folder management with working search.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-notes-creation/03-RESEARCH.md
@.planning/phases/03-notes-creation/03-01-SUMMARY.md

@src/notes.rs (update with CRUD operations)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add note CRUD operations</name>
  <files>src/notes.rs</files>
  <action>
Add helper functions and update the Notes component with note CRUD operations.

1. **Add a UUID generation helper** at module level (after data structures):

```rust
fn generate_id() -> String {
    #[cfg(target_arch = "wasm32")]
    {
        let timestamp = js_sys::Date::now() as u64;
        let random = (js_sys::Math::random() * 1000000.0) as u64;
        format!("{}-{}", timestamp, random)
    }
    #[cfg(not(target_arch = "wasm32"))]
    {
        "test-id".to_string()
    }
}
```

2. **Update the Notes component** to include create/delete handlers:

In the main `Notes` component, add these handlers after the `visible_notes` Memo:

```rust
// Create new note handler
let create_note = move |_| {
    let now = js_sys::Date::now();
    let folder_id = state.get().selected_folder_id.clone()
        .unwrap_or_else(|| "all-notes".to_string());

    // Don't create notes in Recently Deleted
    let actual_folder = if folder_id == "recently-deleted" {
        "all-notes".to_string()
    } else {
        folder_id
    };

    let new_note = Note {
        id: generate_id(),
        folder_id: actual_folder,
        title: "New Note".to_string(),
        content: String::new(),
        created_at: now,
        updated_at: now,
        is_deleted: false,
        deleted_at: None,
    };

    let new_note_id = new_note.id.clone();

    set_state.update(|s| {
        s.notes.insert(0, new_note);
        s.selected_note_id = Some(new_note_id);
    });
};

// Delete note handler (soft delete - moves to Recently Deleted)
let delete_note = move |note_id: String| {
    let now = js_sys::Date::now();
    set_state.update(|s| {
        if let Some(note) = s.notes.iter_mut().find(|n| n.id == note_id) {
            note.is_deleted = true;
            note.deleted_at = Some(now);
        }
        // Clear selection if deleted note was selected
        if s.selected_note_id.as_ref() == Some(&note_id) {
            s.selected_note_id = None;
        }
    });
};

// Permanently delete note handler
let permanent_delete_note = move |note_id: String| {
    set_state.update(|s| {
        s.notes.retain(|n| n.id != note_id);
        if s.selected_note_id.as_ref() == Some(&note_id) {
            s.selected_note_id = None;
        }
    });
};

// Restore note from Recently Deleted
let restore_note = move |note_id: String| {
    set_state.update(|s| {
        if let Some(note) = s.notes.iter_mut().find(|n| n.id == note_id) {
            note.is_deleted = false;
            note.deleted_at = None;
        }
    });
};
```

3. **Update the NotesList component** to accept and use these handlers:

Change the NotesList signature to:

```rust
#[component]
fn NotesList(
    notes: Memo<Vec<Note>>,
    state: ReadSignal<NotesState>,
    set_state: WriteSignal<NotesState>,
    search_query: ReadSignal<String>,
    set_search_query: WriteSignal<String>,
    on_create: impl Fn(leptos::ev::MouseEvent) + 'static + Clone,
    on_delete: impl Fn(String) + 'static + Clone,
    on_restore: impl Fn(String) + 'static + Clone,
    on_permanent_delete: impl Fn(String) + 'static + Clone,
) -> impl IntoView {
```

4. **Update NotesList view** to include action buttons and context-aware delete/restore:

```rust
view! {
    <div class="notes-list">
        <div class="notes-list-header">
            <span class="notes-list-count">{move || format!("{} Notes", notes.get().len())}</span>
            <div class="notes-list-header-actions">
                <button
                    class="notes-action-btn"
                    on:click=on_create.clone()
                    title="New Note"
                >
                    "+"
                </button>
            </div>
        </div>
        <div class="notes-search-bar">
            <span class="notes-search-icon">"üîç"</span>
            <input
                type="text"
                class="notes-search-input"
                placeholder="Search"
                prop:value=move || search_query.get()
                on:input=move |e| {
                    set_search_query.set(event_target_value(&e));
                }
            />
        </div>
        <div class="notes-list-items">
            <For
                each=move || notes.get()
                key=|note| note.id.clone()
                children={
                    let on_delete = on_delete.clone();
                    let on_restore = on_restore.clone();
                    let on_permanent_delete = on_permanent_delete.clone();
                    move |note| {
                        let note_id = note.id.clone();
                        let note_id_for_click = note_id.clone();
                        let note_id_for_action = note_id.clone();
                        let is_deleted = note.is_deleted;
                        let is_selected = {
                            let note_id = note_id.clone();
                            move || selected_note_id() == Some(note_id.clone())
                        };

                        let on_delete = on_delete.clone();
                        let on_restore = on_restore.clone();
                        let on_permanent_delete = on_permanent_delete.clone();

                        view! {
                            <div
                                class=move || if is_selected() { "notes-list-item selected" } else { "notes-list-item" }
                                on:click=move |_| {
                                    set_state.update(|s| {
                                        s.selected_note_id = Some(note_id_for_click.clone());
                                    });
                                }
                            >
                                <div class="notes-list-item-content">
                                    <div class="notes-list-item-title">{note.title.clone()}</div>
                                    <div class="notes-list-item-preview">
                                        <span class="notes-list-item-date">{format_date(note.updated_at)}</span>
                                        <span class="notes-list-item-text">{get_preview(&note.content)}</span>
                                    </div>
                                </div>
                                <div class="notes-list-item-actions">
                                    {if is_deleted {
                                        let note_id_restore = note_id_for_action.clone();
                                        let note_id_perm = note_id_for_action.clone();
                                        let on_restore = on_restore.clone();
                                        let on_permanent_delete = on_permanent_delete.clone();
                                        view! {
                                            <button
                                                class="notes-action-btn secondary"
                                                on:click=move |e: leptos::ev::MouseEvent| {
                                                    e.stop_propagation();
                                                    on_restore(note_id_restore.clone());
                                                }
                                                title="Restore"
                                            >
                                                "‚Ü©"
                                            </button>
                                            <button
                                                class="notes-action-btn danger"
                                                on:click=move |e: leptos::ev::MouseEvent| {
                                                    e.stop_propagation();
                                                    on_permanent_delete(note_id_perm.clone());
                                                }
                                                title="Delete Permanently"
                                            >
                                                "‚úï"
                                            </button>
                                        }.into_any()
                                    } else {
                                        let note_id_del = note_id_for_action.clone();
                                        let on_delete = on_delete.clone();
                                        view! {
                                            <button
                                                class="notes-action-btn secondary"
                                                on:click=move |e: leptos::ev::MouseEvent| {
                                                    e.stop_propagation();
                                                    on_delete(note_id_del.clone());
                                                }
                                                title="Delete"
                                            >
                                                "üóë"
                                            </button>
                                        }.into_any()
                                    }}
                                </div>
                            </div>
                        }
                    }
                }
            />
        </div>
    </div>
}
```

5. **Update the Notes component view** to pass handlers to NotesList:

```rust
view! {
    <div class="notes-app">
        <FolderSidebar state=state set_state=set_state />
        <NotesList
            notes=visible_notes
            state=state
            set_state=set_state
            search_query=search_query
            set_search_query=set_search_query
            on_create=create_note
            on_delete=delete_note
            on_restore=restore_note
            on_permanent_delete=permanent_delete_note
        />
        <NoteEditor state=state set_state=set_state />
    </div>
}
```
  </action>
  <verify>
Run `cargo check` - should compile with no errors.
Run `trunk serve`:
1. Click "+" button - new note created and selected
2. Type in editor, blur - note title updates from content
3. Click trash button on note - note moves to "Recently Deleted"
4. Select "Recently Deleted" folder - deleted note appears
5. Click restore button - note moves back
6. Click permanent delete button - note removed
  </verify>
  <done>
Note CRUD operations work:
- Create note with "+" button
- Soft delete moves to Recently Deleted
- Restore from Recently Deleted
- Permanent delete removes note
  </done>
</task>

<task type="auto">
  <name>Task 2: Add folder CRUD operations</name>
  <files>src/notes.rs</files>
  <action>
Update FolderSidebar to support folder creation, renaming, and deletion.

1. **Add folder handlers in the Notes component** (after note handlers):

```rust
// Create new folder handler
let create_folder = move |_| {
    let now = js_sys::Date::now();
    let new_folder = Folder {
        id: generate_id(),
        name: "New Folder".to_string(),
        is_system: false,
        created_at: now,
    };
    let new_folder_id = new_folder.id.clone();

    set_state.update(|s| {
        s.folders.push(new_folder);
        s.selected_folder_id = Some(new_folder_id);
    });
};

// Delete folder handler (only for non-system folders)
let delete_folder = move |folder_id: String| {
    set_state.update(|s| {
        // Don't delete system folders
        if let Some(folder) = s.folders.iter().find(|f| f.id == folder_id) {
            if folder.is_system {
                return;
            }
        }

        // Move notes from deleted folder to "all-notes" (they become unfiled)
        for note in s.notes.iter_mut() {
            if note.folder_id == folder_id {
                note.folder_id = "all-notes".to_string();
            }
        }

        // Remove the folder
        s.folders.retain(|f| f.id != folder_id);

        // Select "All Notes" if deleted folder was selected
        if s.selected_folder_id.as_ref() == Some(&folder_id) {
            s.selected_folder_id = Some("all-notes".to_string());
        }
    });
};

// Rename folder handler
let rename_folder = move |folder_id: String, new_name: String| {
    set_state.update(|s| {
        if let Some(folder) = s.folders.iter_mut().find(|f| f.id == folder_id) {
            // Don't rename system folders
            if !folder.is_system {
                folder.name = new_name;
            }
        }
    });
};
```

2. **Update FolderSidebar signature** to accept these handlers:

```rust
#[component]
fn FolderSidebar(
    state: ReadSignal<NotesState>,
    set_state: WriteSignal<NotesState>,
    on_create_folder: impl Fn(leptos::ev::MouseEvent) + 'static + Clone,
    on_delete_folder: impl Fn(String) + 'static + Clone,
    on_rename_folder: impl Fn(String, String) + 'static + Clone,
) -> impl IntoView {
```

3. **Update FolderSidebar view** with inline editing and actions:

```rust
view! {
    <div class="notes-folder-sidebar">
        <div class="notes-sidebar-header-row">
            <span class="notes-sidebar-header">"Folders"</span>
            <button
                class="notes-action-btn secondary"
                on:click=on_create_folder.clone()
                title="New Folder"
            >
                "+"
            </button>
        </div>
        <For
            each=folders
            key=|folder| folder.id.clone()
            children={
                let on_delete_folder = on_delete_folder.clone();
                let on_rename_folder = on_rename_folder.clone();
                move |folder| {
                    let folder_id = folder.id.clone();
                    let folder_id_for_click = folder_id.clone();
                    let folder_id_for_count = folder_id.clone();
                    let folder_id_for_delete = folder_id.clone();
                    let folder_id_for_rename = folder_id.clone();
                    let is_system = folder.is_system;
                    let folder_name = folder.name.clone();

                    let (is_editing, set_is_editing) = signal(false);
                    let (edit_value, set_edit_value) = signal(folder_name.clone());

                    let is_selected = move || selected_id() == Some(folder_id.clone());

                    let icon = if is_system {
                        if folder_id == "recently-deleted" { "üóëÔ∏è" } else { "üìÅ" }
                    } else {
                        "üìÇ"
                    };

                    let on_delete_folder = on_delete_folder.clone();
                    let on_rename_folder = on_rename_folder.clone();

                    view! {
                        <div
                            class=move || if is_selected() { "notes-folder-item selected" } else { "notes-folder-item" }
                            on:click=move |_| {
                                if !is_editing.get() {
                                    set_state.update(|s| {
                                        s.selected_folder_id = Some(folder_id_for_click.clone());
                                        s.selected_note_id = None;
                                    });
                                }
                            }
                            on:dblclick=move |_| {
                                if !is_system {
                                    set_edit_value.set(folder_name.clone());
                                    set_is_editing.set(true);
                                }
                            }
                        >
                            <span class="notes-folder-icon">{icon}</span>
                            <Show
                                when=move || is_editing.get()
                                fallback={
                                    let folder_name = folder.name.clone();
                                    move || view! {
                                        <span class="notes-folder-name">{folder_name.clone()}</span>
                                    }
                                }
                            >
                                {
                                    let on_rename_folder = on_rename_folder.clone();
                                    let folder_id_rename = folder_id_for_rename.clone();
                                    view! {
                                        <input
                                            type="text"
                                            class="notes-folder-item-input"
                                            prop:value=move || edit_value.get()
                                            on:input=move |e| {
                                                set_edit_value.set(event_target_value(&e));
                                            }
                                            on:blur=move |_| {
                                                let new_name = edit_value.get();
                                                if !new_name.trim().is_empty() {
                                                    on_rename_folder(folder_id_rename.clone(), new_name);
                                                }
                                                set_is_editing.set(false);
                                            }
                                            on:keydown=move |e: leptos::ev::KeyboardEvent| {
                                                if e.key() == "Enter" {
                                                    let new_name = edit_value.get();
                                                    if !new_name.trim().is_empty() {
                                                        on_rename_folder(folder_id_rename.clone(), new_name);
                                                    }
                                                    set_is_editing.set(false);
                                                } else if e.key() == "Escape" {
                                                    set_is_editing.set(false);
                                                }
                                            }
                                        />
                                    }
                                }
                            </Show>
                            <span class="notes-folder-count">{move || note_count(&folder_id_for_count)}</span>
                            {if !is_system {
                                let on_delete_folder = on_delete_folder.clone();
                                let folder_id_del = folder_id_for_delete.clone();
                                view! {
                                    <button
                                        class="notes-folder-delete-btn"
                                        on:click=move |e: leptos::ev::MouseEvent| {
                                            e.stop_propagation();
                                            on_delete_folder(folder_id_del.clone());
                                        }
                                        title="Delete Folder"
                                    >
                                        "‚úï"
                                    </button>
                                }.into_any()
                            } else {
                                view! { <span></span> }.into_any()
                            }}
                        </div>
                    }
                }
            }
        />
    </div>
}
```

4. **Update the Notes view** to pass folder handlers:

```rust
<FolderSidebar
    state=state
    set_state=set_state
    on_create_folder=create_folder
    on_delete_folder=delete_folder
    on_rename_folder=rename_folder
/>
```

5. **Add CSS for folder actions** (add to styles.css if not already present):

```css
.notes-sidebar-header-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px 8px;
}

.notes-sidebar-header-row .notes-sidebar-header {
    padding: 0;
}

.notes-folder-delete-btn {
    opacity: 0;
    border: none;
    background: transparent;
    color: #999;
    cursor: pointer;
    font-size: 12px;
    padding: 2px 4px;
    margin-left: 4px;
    transition: opacity 0.15s ease;
}

.notes-folder-item:hover .notes-folder-delete-btn {
    opacity: 1;
}

.notes-folder-delete-btn:hover {
    color: #ff3b30;
}

.notes-folder-item.selected .notes-folder-delete-btn {
    color: rgba(255, 255, 255, 0.7);
}

.notes-folder-item.selected .notes-folder-delete-btn:hover {
    color: #fff;
}
```
  </action>
  <verify>
Run `cargo check` - should compile with no errors.
Run `trunk serve`:
1. Click "+" in folder header - new folder created
2. Double-click custom folder - edit mode activates
3. Type new name, press Enter - folder renamed
4. Press Escape - edit cancelled
5. Hover custom folder, click X - folder deleted
6. System folders (All Notes, Recently Deleted) cannot be renamed/deleted
  </verify>
  <done>
Folder CRUD operations work:
- Create folder with "+" button
- Rename folder with double-click and inline edit
- Delete custom folders with X button
- System folders protected
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CSS for notes list actions</name>
  <files>styles.css</files>
  <action>
Add these additional CSS rules to styles.css (end of file) to support the new CRUD UI elements:

```css
/* Notes list header with count and actions */
.notes-list-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08);
    background: rgba(0, 0, 0, 0.02);
}

[data-theme="dark"] .notes-list-header {
    border-bottom-color: rgba(255, 255, 255, 0.08);
    background: rgba(255, 255, 255, 0.02);
}

.notes-list-count {
    font-size: 12px;
    color: #666;
    font-weight: 500;
}

[data-theme="dark"] .notes-list-count {
    color: #8e8e93;
}

/* Notes list item with actions */
.notes-list-item {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    padding: 12px 16px;
    cursor: pointer;
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    transition: background-color 0.15s ease;
}

.notes-list-item-content {
    flex: 1;
    min-width: 0;
    overflow: hidden;
}

.notes-list-item-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.15s ease;
    margin-left: 8px;
    flex-shrink: 0;
}

.notes-list-item:hover .notes-list-item-actions {
    opacity: 1;
}

.notes-list-item.selected .notes-list-item-actions {
    opacity: 1;
}

/* Folder sidebar header row */
.notes-sidebar-header-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px 8px;
}

.notes-sidebar-header-row .notes-sidebar-header {
    padding: 0;
}

.notes-sidebar-header-row .notes-action-btn {
    width: 22px;
    height: 22px;
    font-size: 14px;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Folder delete button */
.notes-folder-delete-btn {
    opacity: 0;
    border: none;
    background: transparent;
    color: #999;
    cursor: pointer;
    font-size: 11px;
    padding: 2px 4px;
    margin-left: 4px;
    transition: opacity 0.15s ease;
    flex-shrink: 0;
}

.notes-folder-item:hover .notes-folder-delete-btn {
    opacity: 1;
}

.notes-folder-delete-btn:hover {
    color: #ff3b30;
}

.notes-folder-item.selected .notes-folder-delete-btn {
    color: rgba(255, 255, 255, 0.7);
}

.notes-folder-item.selected .notes-folder-delete-btn:hover {
    color: #fff;
}

/* Smaller action buttons for list items */
.notes-list-item-actions .notes-action-btn {
    padding: 2px 8px;
    font-size: 11px;
}
```
  </action>
  <verify>
Run `trunk serve`:
- Hover over notes to see action buttons appear
- Hover over folders to see delete button appear
- Check styling in both light and dark modes
  </verify>
  <done>
CSS styles support CRUD UI elements with proper hover states and visibility.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check` passes
2. `trunk serve` serves the app
3. Note operations:
   - "+" button creates new note
   - New note is selected and editor is active
   - Typing in note updates title from first line
   - Delete button moves note to Recently Deleted
   - In Recently Deleted: restore and permanent delete buttons work
4. Folder operations:
   - "+" button creates new folder
   - Double-click folder to rename (Enter to save, Escape to cancel)
   - X button deletes custom folder
   - System folders cannot be modified
5. Search:
   - Type in search box
   - Notes filter by title and content
   - Clear search shows all notes
6. All state persists after refresh
</verification>

<success_criteria>
- Create, delete, restore notes working
- Create, rename, delete folders working
- Search filters notes in real-time
- UI actions have proper feedback (hover states, visibility)
- State persists to localStorage
- System folders protected from modification
</success_criteria>

<output>
After completion, create `.planning/phases/03-notes-creation/03-04-SUMMARY.md`
</output>
