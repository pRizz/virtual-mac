---
phase: 03-notes-creation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/notes.rs
  - src/lib.rs
  - src/window_manager.rs
autonomous: true

must_haves:
  truths:
    - "Notes app renders in a window"
    - "Three-column layout visible (folders, notes list, editor)"
    - "Default folders exist (All Notes, Recently Deleted)"
    - "Notes state persists to localStorage"
  artifacts:
    - path: "src/notes.rs"
      provides: "Notes component with three-column layout"
      min_lines: 150
      exports: ["Notes"]
    - path: "src/lib.rs"
      provides: "Module declaration for notes"
      contains: "mod notes"
    - path: "src/window_manager.rs"
      provides: "AppType::Notes variant and rendering"
      contains: "AppType::Notes"
  key_links:
    - from: "src/window_manager.rs"
      to: "src/notes.rs"
      via: "import and render"
      pattern: "use crate::notes::Notes"
    - from: "src/notes.rs"
      to: "localStorage"
      via: "web_sys Storage"
      pattern: "local_storage"
---

<objective>
Create the Notes app component with three-column layout, data model, and localStorage persistence.

Purpose: Establish the foundation that all other Notes features build upon - the component structure, data types, and persistence layer.

Output: A working Notes app window with visible three-column layout showing default folders and placeholder content.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-notes-creation/03-RESEARCH.md

@src/textedit.rs (reference for contenteditable pattern)
@src/finder.rs (reference for multi-column layout)
@src/window_manager.rs (integration point for AppType)
@src/lib.rs (module declarations)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notes.rs with data model and three-column layout</name>
  <files>src/notes.rs</files>
  <action>
Create src/notes.rs with:

1. **Data structures** (at top of file):
```rust
use serde::{Serialize, Deserialize};

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct Note {
    pub id: String,
    pub folder_id: String,
    pub title: String,
    pub content: String,  // HTML content
    pub created_at: f64,
    pub updated_at: f64,
    pub is_deleted: bool,
    pub deleted_at: Option<f64>,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct Folder {
    pub id: String,
    pub name: String,
    pub is_system: bool,  // true for All Notes, Recently Deleted
    pub created_at: f64,
}

#[derive(Clone, Debug, Serialize, Deserialize, Default)]
pub struct NotesState {
    pub folders: Vec<Folder>,
    pub notes: Vec<Note>,
    pub selected_folder_id: Option<String>,
    pub selected_note_id: Option<String>,
}
```

2. **Default state with system folders**:
```rust
impl NotesState {
    pub fn default_with_system_folders() -> Self {
        let now = js_sys::Date::now();
        Self {
            folders: vec![
                Folder {
                    id: "all-notes".to_string(),
                    name: "All Notes".to_string(),
                    is_system: true,
                    created_at: now,
                },
                Folder {
                    id: "recently-deleted".to_string(),
                    name: "Recently Deleted".to_string(),
                    is_system: true,
                    created_at: now,
                },
            ],
            notes: vec![],
            selected_folder_id: Some("all-notes".to_string()),
            selected_note_id: None,
        }
    }
}
```

3. **localStorage persistence** (follow theme.rs pattern):
```rust
fn save_to_storage(state: &NotesState) {
    #[cfg(target_arch = "wasm32")]
    {
        if let Some(window) = web_sys::window() {
            if let Ok(Some(storage)) = window.local_storage() {
                if let Ok(json) = serde_json::to_string(state) {
                    let _ = storage.set_item("virtualmac_notes", &json);
                }
            }
        }
    }
}

fn load_from_storage() -> NotesState {
    #[cfg(target_arch = "wasm32")]
    {
        if let Some(window) = web_sys::window() {
            if let Ok(Some(storage)) = window.local_storage() {
                if let Ok(Some(json)) = storage.get_item("virtualmac_notes") {
                    if let Ok(state) = serde_json::from_str(&json) {
                        return state;
                    }
                }
            }
        }
    }
    NotesState::default_with_system_folders()
}
```

4. **Main Notes component** with three-column structure:
```rust
#[component]
pub fn Notes() -> impl IntoView {
    let (state, set_state) = signal(load_from_storage());
    let (search_query, set_search_query) = signal(String::new());

    // Auto-save on state changes
    Effect::new(move |_| {
        let current_state = state.get();
        save_to_storage(&current_state);
    });

    // Compute visible notes based on selected folder and search
    let visible_notes = Memo::new(move |_| {
        let st = state.get();
        let query = search_query.get().to_lowercase();
        let folder_id = st.selected_folder_id.clone();

        st.notes.iter()
            .filter(|n| {
                // Filter by folder
                let folder_match = match folder_id.as_deref() {
                    Some("all-notes") => !n.is_deleted,
                    Some("recently-deleted") => n.is_deleted,
                    Some(fid) => n.folder_id == fid && !n.is_deleted,
                    None => !n.is_deleted,
                };
                // Filter by search
                let search_match = query.is_empty()
                    || n.title.to_lowercase().contains(&query)
                    || n.content.to_lowercase().contains(&query);
                folder_match && search_match
            })
            .cloned()
            .collect::<Vec<_>>()
    });

    view! {
        <div class="notes-app">
            <FolderSidebar state=state set_state=set_state />
            <NotesList
                notes=visible_notes
                state=state
                set_state=set_state
                search_query=search_query
                set_search_query=set_search_query
            />
            <NoteEditor state=state set_state=set_state />
        </div>
    }
}
```

5. **FolderSidebar component**:
```rust
#[component]
fn FolderSidebar(
    state: ReadSignal<NotesState>,
    set_state: WriteSignal<NotesState>,
) -> impl IntoView {
    let folders = move || state.get().folders.clone();
    let selected_id = move || state.get().selected_folder_id.clone();

    // Count notes per folder
    let note_count = move |folder_id: &str| {
        let st = state.get();
        if folder_id == "all-notes" {
            st.notes.iter().filter(|n| !n.is_deleted).count()
        } else if folder_id == "recently-deleted" {
            st.notes.iter().filter(|n| n.is_deleted).count()
        } else {
            st.notes.iter().filter(|n| n.folder_id == folder_id && !n.is_deleted).count()
        }
    };

    view! {
        <div class="notes-folder-sidebar">
            <div class="notes-sidebar-header">"Folders"</div>
            <For
                each=folders
                key=|folder| folder.id.clone()
                children=move |folder| {
                    let folder_id = folder.id.clone();
                    let folder_id_for_click = folder_id.clone();
                    let folder_id_for_count = folder_id.clone();
                    let is_selected = move || selected_id() == Some(folder_id.clone());
                    let icon = if folder.is_system {
                        if folder.id == "recently-deleted" { "üóëÔ∏è" } else { "üìÅ" }
                    } else {
                        "üìÇ"
                    };
                    view! {
                        <div
                            class=move || if is_selected() { "notes-folder-item selected" } else { "notes-folder-item" }
                            on:click=move |_| {
                                set_state.update(|s| {
                                    s.selected_folder_id = Some(folder_id_for_click.clone());
                                    s.selected_note_id = None;
                                });
                            }
                        >
                            <span class="notes-folder-icon">{icon}</span>
                            <span class="notes-folder-name">{folder.name.clone()}</span>
                            <span class="notes-folder-count">{move || note_count(&folder_id_for_count)}</span>
                        </div>
                    }
                }
            />
        </div>
    }
}
```

6. **NotesList component**:
```rust
#[component]
fn NotesList(
    notes: Memo<Vec<Note>>,
    state: ReadSignal<NotesState>,
    set_state: WriteSignal<NotesState>,
    search_query: ReadSignal<String>,
    set_search_query: WriteSignal<String>,
) -> impl IntoView {
    let selected_note_id = move || state.get().selected_note_id.clone();

    // Format date for display
    fn format_date(timestamp: f64) -> String {
        #[cfg(target_arch = "wasm32")]
        {
            let date = js_sys::Date::new(&wasm_bindgen::JsValue::from_f64(timestamp));
            let month = date.get_month() + 1.0;
            let day = date.get_date();
            format!("{}/{}", month as u32, day as u32)
        }
        #[cfg(not(target_arch = "wasm32"))]
        {
            "1/1".to_string()
        }
    }

    // Extract preview text from HTML content
    fn get_preview(content: &str) -> String {
        // Strip HTML tags for preview
        let text = content
            .replace("<br>", " ")
            .replace("<br/>", " ")
            .replace("</p>", " ")
            .replace("</div>", " ");
        // Simple tag stripping
        let mut result = String::new();
        let mut in_tag = false;
        for c in text.chars() {
            if c == '<' { in_tag = true; }
            else if c == '>' { in_tag = false; }
            else if !in_tag { result.push(c); }
        }
        result.chars().take(50).collect::<String>() + if result.len() > 50 { "..." } else { "" }
    }

    view! {
        <div class="notes-list">
            <div class="notes-search-bar">
                <span class="notes-search-icon">"üîç"</span>
                <input
                    type="text"
                    class="notes-search-input"
                    placeholder="Search"
                    prop:value=move || search_query.get()
                    on:input=move |e| {
                        set_search_query.set(event_target_value(&e));
                    }
                />
            </div>
            <div class="notes-list-items">
                <For
                    each=move || notes.get()
                    key=|note| note.id.clone()
                    children=move |note| {
                        let note_id = note.id.clone();
                        let note_id_for_click = note_id.clone();
                        let is_selected = move || selected_note_id() == Some(note_id.clone());
                        view! {
                            <div
                                class=move || if is_selected() { "notes-list-item selected" } else { "notes-list-item" }
                                on:click=move |_| {
                                    set_state.update(|s| {
                                        s.selected_note_id = Some(note_id_for_click.clone());
                                    });
                                }
                            >
                                <div class="notes-list-item-title">{note.title.clone()}</div>
                                <div class="notes-list-item-preview">
                                    <span class="notes-list-item-date">{format_date(note.updated_at)}</span>
                                    <span class="notes-list-item-text">{get_preview(&note.content)}</span>
                                </div>
                            </div>
                        }
                    }
                />
            </div>
        </div>
    }
}
```

7. **NoteEditor component** (basic structure, formatting added in Plan 03):
```rust
#[component]
fn NoteEditor(
    state: ReadSignal<NotesState>,
    set_state: WriteSignal<NotesState>,
) -> impl IntoView {
    let editor_ref: NodeRef<html::Div> = NodeRef::new();

    let selected_note = Memo::new(move |_| {
        let st = state.get();
        st.selected_note_id.as_ref().and_then(|id| {
            st.notes.iter().find(|n| &n.id == id).cloned()
        })
    });

    // Load content into editor when selected note changes
    Effect::new(move |_| {
        if let Some(note) = selected_note.get() {
            if let Some(el) = editor_ref.get() {
                el.set_inner_html(&note.content);
            }
        } else {
            if let Some(el) = editor_ref.get() {
                el.set_inner_html("");
            }
        }
    });

    // Save content on blur
    let on_blur = move |_| {
        if let Some(el) = editor_ref.get() {
            let content = el.inner_html();
            set_state.update(|s| {
                if let Some(note_id) = &s.selected_note_id {
                    if let Some(note) = s.notes.iter_mut().find(|n| &n.id == note_id) {
                        note.content = content.clone();
                        note.updated_at = js_sys::Date::now();
                        // Update title from first line
                        let title = content
                            .split("<br>")
                            .next()
                            .or_else(|| content.split("<div>").next())
                            .map(|s| {
                                // Strip tags
                                let mut result = String::new();
                                let mut in_tag = false;
                                for c in s.chars() {
                                    if c == '<' { in_tag = true; }
                                    else if c == '>' { in_tag = false; }
                                    else if !in_tag { result.push(c); }
                                }
                                result.trim().to_string()
                            })
                            .filter(|s| !s.is_empty())
                            .unwrap_or_else(|| "New Note".to_string());
                        note.title = title;
                    }
                }
            });
        }
    };

    view! {
        <div class="notes-editor">
            <div class="notes-editor-toolbar">
                // Placeholder toolbar - formatting buttons added in Plan 03
                <div class="notes-toolbar-placeholder">"Formatting"</div>
            </div>
            <Show
                when=move || selected_note.get().is_some()
                fallback=|| view! {
                    <div class="notes-editor-empty">
                        <div class="notes-editor-empty-text">"Select a note or create a new one"</div>
                    </div>
                }
            >
                <div
                    class="notes-editor-content"
                    contenteditable="true"
                    node_ref=editor_ref
                    on:blur=on_blur
                />
            </Show>
        </div>
    }
}
```

Required imports at top:
```rust
use leptos::prelude::*;
use leptos::html;
use serde::{Serialize, Deserialize};
use wasm_bindgen::prelude::*;
```
  </action>
  <verify>
Run `cargo check` - should compile with no errors.
Check that src/notes.rs exists with ~250+ lines.
  </verify>
  <done>
notes.rs exists with Note, Folder, NotesState structs, localStorage persistence, and Notes component with FolderSidebar, NotesList, NoteEditor subcomponents.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate Notes into window_manager.rs and lib.rs</name>
  <files>src/lib.rs, src/window_manager.rs</files>
  <action>
1. **In src/lib.rs**, add module declaration (after `mod terminal;`):
```rust
mod notes;
```

2. **In src/window_manager.rs**:

a) Add import at top (with other crate imports):
```rust
use crate::notes::Notes;
```

b) Add `Notes` variant to `AppType` enum (after `TextEdit`):
```rust
pub enum AppType {
    Generic,
    Calculator,
    SystemSettings,
    Terminal,
    TextEdit,
    Notes,  // Add this
}
```

c) Update the initial windows list to use AppType::Notes (~line 145):
Change:
```rust
WindowState::new(5, "Notes", 450.0, 220.0, 400.0, 300.0),
```
To:
```rust
WindowState::new_with_app(5, "Notes", 450.0, 220.0, 700.0, 500.0, AppType::Notes),
```
Note: Increased size to 700x500 for better three-column display.

d) Add boolean check for Notes (~line 689, after is_textedit):
```rust
let is_notes = app_type == AppType::Notes;
```

e) Add rendering match arm (~line 746, after textedit block):
```rust
} else if is_notes {
    view! { <Notes /> }.into_any()
```
  </action>
  <verify>
Run `cargo check` - should compile with no errors.
Run `trunk serve` and open browser - Notes window should appear with three-column layout visible.
  </verify>
  <done>
Notes app integrated into window system, appears in initial windows list, renders Notes component when window opens.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cargo check` passes
2. `trunk serve` serves the app
3. Notes window visible on desktop
4. Three columns visible (folders, list, editor)
5. "All Notes" and "Recently Deleted" folders appear in sidebar
6. Empty state message shows in editor ("Select a note or create a new one")
7. Refresh page, state persists (check localStorage for virtualmac_notes key)
</verification>

<success_criteria>
- Notes app renders in window with three-column layout
- Default system folders visible
- Editor shows empty state when no note selected
- localStorage contains virtualmac_notes key after interaction
- No console errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-notes-creation/03-01-SUMMARY.md`
</output>
